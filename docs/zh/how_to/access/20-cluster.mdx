---
weight: 20
sourceSHA: 0b3baf38526ebaf359b0f8c305016fc29490a45507d33e3c007842559df06d35
---

# 如何访问集群实例

本指南演示了如何使用行业标准的客户端库连接到 Redis 集群实例。示例涵盖了 [go-redis](https://github.com/redis/go-redis)、[Jedis](https://github.com/redis/jedis)、[Lettuce](https://github.com/lettuce-io/lettuce-core) 和 [Redisson](https://github.com/redisson/redisson) 的配置细节。有关其他客户端选项，请参阅 [使用 Redis 客户端 API 库连接](https://redis.io/clients)。

## 认证要求

Redis 集群实例实现以下认证选项：

- **密码认证**：如果配置了密码，则所有客户端连接必须提供有效的凭据。
- **无密码访问**：如果在实例创建时禁用 **设置密码** 选项，客户端可以无需认证进行连接。

<Directive type="warning" title="安全最佳实践">
  对于生产环境，强烈建议实施密码认证以保护您的数据。有关配置和维护安全凭据的详细说明，请参阅 [用户管理](../../functions/20-user)。
</Directive>

## 连接终端参考

### 内部集群访问

对于部署在同一 Kubernetes 集群内的应用程序，可以通过 **集群内访问** 部分下的 **访问方法** 标签获得内部访问终端。

| 参数                   | 描述                                                                            |
| ---------------------- | ------------------------------------------------------------------------------- |
| **连接地址**          | Redis 集群中每个分片的 Kubernetes 服务名称和端口组合                         |

### 外部集群访问

对于从 Kubernetes 环境外部连接的应用程序，可以在实例创建时配置外部访问终端。这些终端可以在 **集群外部访问** 部分下的 **访问方法** 标签中找到。

| 终端类型          | 描述                                                                                                                              |
| ----------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| **分片地址**      | Redis 集群中分片的外部 IP 地址和端口，使其能够从 Kubernetes 网络外部进行连接                                                   |

## 交互式调试

对于管理操作和故障排除，Redis CLI 提供对集群节点的直接访问：

1. 从实例详情页面访问 **终端控制台**
2. 使用集群感知客户端模式连接到任何节点：

```bash
redis-cli -c -h <internal-routing-ip> -p 6379
```

示例调试会话演示基于槽的重定向：

```bash
192.168.0.10:6379> set a 1
-> 重定向到槽 [15495] 位于 192.168.0.10:6379
OK
192.168.0.10:6379> get a
"1"
192.168.0.10:6379>
```

`-c` 标志启用 `MOVED` 和 `ASK` 重定向的自动跟随，这在使用 Redis 集群时是必不可少的。

## 客户端集成示例

以下示例演示了使用各种客户端库连接到 Redis 集群实例的最佳实践。

<Tabs>
  <Tab label="go-redis">
    ```go
    package main

    import (
        "context"
        "fmt"
        "time"
        // 建议定期升级到最新版本的客户端以获得最新的 bug 修复。
        "github.com/redis/go-redis/v9"
    )

    func main() {
        client := redis.NewClusterClient(&redis.ClusterOptions{
            Addrs:    []string{"<address>"},
            Password: "<password>",
            OnConnect: func(ctx context.Context, conn *redis.Conn) error {
                ctx, cancel := context.WithTimeout(ctx, 500*time.Millisecond)
                defer cancel()
                return conn.Ping(ctx).Err()
            },
            // 客户端名称，用于跟踪目的
            ClientName: "go-demo",
            // 使用上下文进行时间控制
            ContextTimeoutEnabled: true,
            // 在 MOVED 或 ASK 的情况下最大重定向次数
            MaxRedirects: 3,
            // 最大重试次数
            MaxRetries: 3,
            // 最小重试退避
            MinRetryBackoff: 20 * time.Millisecond,
            // 最大重试退避
            MaxRetryBackoff: 200 * time.Millisecond,
            // 连接超时
            DialTimeout: 3 * time.Second,
            // 读取超时
            ReadTimeout: 5 * time.Second,
            // 写入超时
            WriteTimeout: 10 * time.Second,
            // 每个节点的连接池大小
            PoolSize: 100,
            // 连接池中可用连接的最大等待时间
            PoolTimeout: time.Second,
            // 每个节点的最小空闲连接数
            MinIdleConns: 5,
            // 每个节点的最大空闲连接数
            MaxIdleConns: 10,
            // 每个节点的最大活动连接数
            MaxActiveConns: 100,
            // 连接的最大空闲时间
            ConnMaxIdleTime: time.Minute * 5,
        })
        defer client.Close()

        if val, err := client.Get(context.TODO(), "test").Result(); err != nil {
            panic(err)
        } else {
            fmt.Println(val)
        }
    }
    ```

    有关更详细的配置，请参阅 [社区文档](https://redis.uptrace.dev/guide/go-redis-cluster.html)
  </Tab>

  <Tab label="Jedis">
    ```java
    package io.alauda.demo.redis;

    // 建议定期升级到最新版本的客户端以获得最新的 bug 修复。
    import redis.clients.jedis.DefaultJedisClientConfig;
    import redis.clients.jedis.JedisSentinelPool;
    import redis.clients.jedis.JedisPoolConfig;
    import redis.clients.jedis.Jedis;
    import redis.clients.jedis.HostAndPort;

    import java.time.Duration;
    import java.util.Set;
    import java.util.HashSet;

    public class Main {
        public static void main(String []args) {
            JedisPoolConfig poolConfig = new JedisPoolConfig();
            // 设置连接池的大小，-1 表示无限制。如果当前连接数超过该值，则新连接将失败。
            poolConfig.setMaxTotal(200);
            // 设置最大空闲连接数；超过此数的空闲连接将立即释放。
            poolConfig.setMaxIdle(10);
            // 设置最小空闲连接数；空闲连接低于此将被创建。
            poolConfig.setMinIdle(3);
            // 达到最大连接数时无可用连接的最大等待时间。
            poolConfig.setMaxWait(Duration.ofSeconds(1));
            // 每次从池中借用连接时 PING 以验证连接是否可用。
            poolConfig.setTestOnBorrow(true);
            // 测试空闲连接以找出无效连接并释放；此配置仅在 timeBetweenEvictionRunsMillis 大于 1ms 时生效。
            poolConfig.setTestWhileIdle(true);
            // 设置连接的最小空闲时间；超过此时间的连接将被释放；-1 表示不释放；此配置仅在 timeBetweenEvictionRunsMillis 大于 0 时生效。默认值为 30m。
            poolConfig.setMinEvictableIdleDuration(Duration.ofMinutes(5));
            // 检测空闲连接时验证的连接数；-n 表示当前连接的 1/n。
            poolConfig.setNumTestsPerEvictionRun(-1);
            // 驱逐间隔；-1 表示禁用。
            poolConfig.setTimeBetweenEvictionRuns(Duration.ofMinutes(1));

            DefaultJedisClientConfig clientConfig = DefaultJedisClientConfig.builder()
                    // 用于调试时检查连接来源的客户端名称。
                    .clientName("demo-jedis")
                    // TCP 连接超时。
                    .connectionTimeoutMillis(2000)
                    // 命令超时。
                    .timeoutMillis(10000)
                    .password("<password>")
                    .build();

            DefaultJedisClientConfig sentinelConfig = DefaultJedisClientConfig.builder()
                    .connectionTimeoutMillis(2000)
                    .timeoutMillis(10000)
                    .build();

            Set<HostAndPort> nodes =  new HashSet<>();
            nodes.add(new HostAndPort("<ip1>", "<port1>"));
            nodes.add(new HostAndPort("<ip2>", "<port2>"));
            JedisSentinelPool pool = new JedisSentinelPool("mymaster", nodes, poolConfig, clientConfig, sentinelConfig);

            try {
                try (Jedis jedis = pool.getResource()) {
                    String val = jedis.get("test");
                    System.out.printf("%s", val);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            pool.close();
        }
    }
    ```

    有关更详细的配置，请参阅 [社区文档](https://www.javadoc.io/doc/redis.clients/jedis/5.1.2/redis/clients/jedis/Jedis.html)
  </Tab>

  <Tab label="Lettuce">
    ```java
    package io.alauda.demo.redis;

    // 建议定期升级到最新版本的客户端以获得最新的 bug 修复。
    import io.lettuce.core.ClientOptions;
    import io.lettuce.core.RedisURI;
    import io.lettuce.core.SocketOptions;
    import io.lettuce.core.TimeoutOptions;
    import io.lettuce.core.cluster.ClusterClientOptions;
    import io.lettuce.core.cluster.ClusterTopologyRefreshOptions;
    import io.lettuce.core.cluster.RedisClusterClient;
    import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
    import io.lettuce.core.support.ConnectionPoolSupport;
    import org.apache.commons.pool2.impl.GenericObjectPool;
    import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

    import java.time.Duration;
    import java.util.List;
    import java.util.ArrayList;

    public class Main {
        public static void main(String[] args) {
            RedisURI node1 = RedisURI.create("<ip1>", "<port1>");
            node1.setPassword("<password>");
            node1.setClientName("demo-lettuce");

            RedisURI node2 = RedisURI.create("<ip2>", "<port2>");
            node2.setPassword("<password>");
            node2.setClientName("demo-lettuce");

            List<RedisURI> nodes = new ArrayList<>();
            nodes.add(node1);
            nodes.add(node2);

            ClusterTopologyRefreshOptions refreshOptions = ClusterTopologyRefreshOptions.builder()
                    // 默认的拓扑刷新间隔为 60 秒。
                    .enablePeriodicRefresh()
                    // 遇到以下错误时触发拓扑刷新：ASK_REDIRECT、MOVED_REDIRECT、PERSISTENT_RECONNECTS、UNCOVERED_SLOT、UNKNOWN_NODE
                    .enableAllAdaptiveRefreshTriggers()
                    .build();

            TimeoutOptions timeoutOptions = TimeoutOptions.builder()
                    // 设置命令超时。
                    .fixedTimeout(Duration.ofSeconds(10))
                    .build();

            SocketOptions socketOptions = SocketOptions.builder()
                    // 设置连接超时。
                    .connectTimeout(Duration.ofSeconds(10))
                    .tcpNoDelay(true)
                    // 启用 TCP keepalive，以快速识别无效连接。
                    // 对于非 pub/sub 请求，此值并不是强制的；可以通过及时释放空闲连接来进行管理。
                    .keepAlive(true)
                    .build();

            ClusterClientOptions clusterClientOptions = ClusterClientOptions.builder()
                    .topologyRefreshOptions(refreshOptions)
                    // 设置命令超时。
                    .timeoutOptions(timeoutOptions)
                    // 自动重连（默认行为）。
                    .autoReconnect(true)
                    // 配置断开连接时的客户端行为。
                    // DEFAULT - 当 autoReconnect = true 时，接收到的命令不会被拒绝；否则，命令将被拒绝。
                    .disconnectedBehavior(ClientOptions.DisconnectedBehavior.DEFAULT)
                    // 配置 socket 参数；lettuce 默认不启用 keepalive；对于长连接业务需求，应该启用。
                    .socketOptions(socketOptions)
                    .build();

            RedisClusterClient redisClient = RedisClusterClient.create(nodes);
            redisClient.setOptions(clusterClientOptions);

            GenericObjectPoolConfig<StatefulRedisClusterConnection<String, String>> poolConfig = new GenericObjectPoolConfig<>();
            // 连接池大小不宜过大，以免浪费服务器连接资源，导致连接枯竭和实例不可用。
            // 建议估算您的业务并发数除以分片数；最终值应该是 1.2-1.5 倍。
            poolConfig.setMaxTotal(200);
            // 保留的最小空闲连接数，以便更快的业务响应。
            poolConfig.setMinIdle(3);
            // 最大空闲连接数；超过此限制将立即释放空闲连接。
            poolConfig.setMaxIdle(10);
            // 连接的最小空闲持续时间。
            poolConfig.setMinEvictableIdleDuration(Duration.ofMinutes(5));
            // 每次空闲连接检查时验证的连接数；-n 表示当前连接的 1/n。
            poolConfig.setNumTestsPerEvictionRun(3);
            // 驱逐间隔；-1 表示禁用。
            poolConfig.setTimeBetweenEvictionRuns(Duration.ofMinutes(1));
            // 达到最大连接数时无可用连接的最大等待时间。
            poolConfig.setMaxWait(Duration.ofSeconds(1));
            // 每次借用连接时 PING 以验证连接是否可用。
            poolConfig.setTestOnBorrow(true);
            // 测试空闲连接以找出无效连接并释放；此配置仅在 timeBetweenEvictionRunsMillis 大于 1ms 时生效。
            poolConfig.setTestWhileIdle(true);

            GenericObjectPool<StatefulRedisClusterConnection<String, String>> pool = ConnectionPoolSupport
                    .createGenericObjectPool(redisClient::connect, poolConfig);

            try {
                try (StatefulRedisClusterConnection<String, String> connection = pool.borrowObject()) {
                    String val = connection.sync().get("test");
                    System.out.printf("%s", val);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            pool.close();
        }
    }
    ```

    有关更详细的配置，请参阅 [社区文档](https://lettuce.io/core/release/reference/#redis-cluster)
  </Tab>

  <Tab label="Redisson">
    ```java
    package io.alauda.demo.redis;

    // 建议定期升级到最新版本的客户端以获得最新的 bug 修复。
    import org.redisson.Redisson;
    import org.redisson.api.RedissonClient;
    import org.redisson.config.Config;

    import java.util.List;
    import java.util.ArrayList;

    public class Main {
        public static void main(String[] args) {
            List<String> nodes = new ArrayList<>();
            nodes.add("redis://<ip1>:<port1>");
            nodes.add("redis://<ip2>:<port2>");

            Config config = new Config();
            config
                    .setNettyThreads(64)
                    .useClusterServers()
                    .addNodeAddress(nodes.toArray(new String[0]))
                    .setPassword("<password>")
                    // 启动服务时检查集群槽的状态。
                    .setCheckSlotsCoverage(true)
                    // 扫描集群拓扑的间隔。
                    .setScanInterval(5000)
                    // 连接超时。
                    .setConnectTimeout(10000)
                    // 命令超时。
                    .setTimeout(10000)
                    // 每 30 秒测试一次连接的可用性。
                    // 如果启用 KeepAlive，则此超时可相应延长。
                    .setPingConnectionInterval(30000)
                    // 空闲连接超时；丢弃空闲超过 60 秒的连接，默认的 10 秒太短。
                    .setIdleConnectionTimeout(60000)
                    // 连接池大小不宜过大，以免浪费服务器连接资源，导致连接枯竭和实例不可用。
                    // 建议估算您的业务并发数除以分片数；最终值应该是 1.2-1.5 倍。
                    .setMasterConnectionPoolSize(200)
                    // 保留的最小空闲连接数，以便更快的业务响应。
                    .setMasterConnectionMinimumIdleSize(10)
                    // 失败命令的重试次数。
                    .setRetryAttempts(3)
                    // 失败命令的重试间隔。
                    .setRetryInterval(1500)
                    // 启用 TCP keepalive 机制，以快速发现意外断开的连接。
                    .setKeepAlive(true)
                    // TCP 无延迟。
                    .setTcpNoDelay(true)
                    // 用于调试时检查连接来源的客户端名称。
                    .setClientName("demo-redisson");
            RedissonClient redissonClient = Redisson.create(config);

            System.out.printf("%s", redissonClient.getBucket("test").get().toString());

            redissonClient.shutdown();
        }
    }
    ```

    有关更详细的配置，请参阅 [社区文档](https://redisson.org/docs/configuration/#cluster-mode)
  </Tab>
</Tabs>
