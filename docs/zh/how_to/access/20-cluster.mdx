---
weight: 20
---

# 如何访问集群实例

示例展示了如何使用 [go-redis](https://github.com/redis/go-redis), [Jedis](https://github.com/redis/jedis), [Lettuce](https://github.com/lettuce-io/lettuce-core), [Redisson](https://github.com/redisson/redisson) 客户端访问 Redis（集群模式）。更多可选客户端，[查看 Redis 社区客户端推荐](https://redis.io/clients)

## 获取访问信息

* 如果您已为 Redis 设置密码，需使用该密码。

* 如果您已关闭 **设置密码**，则可无密码访问实例。<br/>

<Directive type="warning" title="注意">

**提示**：为确保环境安全，建议您参考 [用户管理](../../functions/20-user) 设置密码 ，并使用已设置的密码访问 Redis。

</Directive>

## 获取连接信息

### 用于集群内

实例创建完毕后，可在实例的 **访问方式** 页签中查询用于 **集群内** 访问的信息。

| 参数 | 说明 |
| --- | --- |
| **连接地址（通过各分片的内部路由）** | 内部路由名称与端口。 |



### 用于集群外

* **通过 Pod 的 NodePort**：在实例 **访问方式** 页签中，客户端可通过 **集群外访问 — 通过 Pod 的 NodePort** 区域内的节点访问地址连接 Redis。

* **通过 Predixy【不推荐】**：为 Predixy 开启 NodePort 以实现集群外访问。请注意，**Predixy 不支持暴露 IPv6 地址**。


## 调试 Redis

在实例详细信息页，单击右上角 **终端控制台**，通过 `redis-cli -c` 命令连接 Redis 各节点。

```
redis-cli -c -h {内部路由的 IP} -p 6379
```

调试示例如下。

```
192.168.0.10:6379> set a 1
-> Redirected to slot [15495] located at 192.168.0.10:6379
OK
192.168.0.10:6379> get a
"1"
192.168.0.10:6379>
```

## 连接 Redis

以下列出了常用 Redis 的实例代码，仅供参考。

<Tabs>

<Tab label="go-redis">

    ```go
    package main

    import (
        "context"
        "fmt"
        "time"
        // 建议定期升级到客户端的最新版本，以获得最新的 bug 修复。
        "github.com/redis/go-redis/v9"
    )

    func main() {
        client := redis.NewClusterClient(&redis.ClusterOptions{
            Addrs:    []string{"<address>"},
            Password: "<password>",
            OnConnect: func(ctx context.Context, conn *redis.Conn) error {
                ctx, cancel := context.WithTimeout(ctx, 500*time.Millisecond)
                defer cancel()
                return conn.Ping(ctx).Err()
            },
            // 客户端名称，用于标识客户端方便追踪
            ClientName: "go-demo",
            // 使用 Context 进行超时控制
            ContextTimeoutEnabled: true,
            // 在遇到 MOVED 或 ASK 时，最大重定向次数
            MaxRedirects: 3,
            // 最大重试次数
            MaxRetries: 3,
            // 重试最小间隔
            MinRetryBackoff: 20 * time.Millisecond,
            // 重试最大间隔
            MaxRetryBackoff: 200 * time.Millisecond,
            // 连接超时
            DialTimeout: 3 * time.Second,
            // 读超时
            ReadTimeout: 5 * time.Second,
            // 写超时
            WriteTimeout: 10 * time.Second,
            // 每个节点连接池大小
            PoolSize: 100,
            // 等待连接池可用连接的最大等待时间
            PoolTimeout: time.Second,
            // 每个节点最小空闲连接数
            MinIdleConns: 5,
            // 每个节点最大空闲连接数
            MaxIdleConns: 10,
            // 每个节点最大活跃连接数
            MaxActiveConns: 100,
            // 连接最大空闲时间
            ConnMaxIdleTime: time.Minute * 5,
        })
        defer client.Close()

        if val, err := client.Get(context.TODO(), "test").Result(); err != nil {
            panic(err)
        } else {
            fmt.Println(val)
        }
    }
    ```

    更多更详细配置请参考[社区文档](https://redis.uptrace.dev/guide/go-redis-cluster.html)

</Tab>

<Tab label="Jedis">

    ```java
    package io.alauda.demo.redis;

    // 建议定期升级到客户端的最新版本，以获得最新的 bug 修复。
    import redis.clients.jedis.DefaultJedisClientConfig;
    import redis.clients.jedis.JedisSentinelPool;
    import redis.clients.jedis.JedisPoolConfig;
    import redis.clients.jedis.Jedis;
    import redis.clients.jedis.HostAndPort;

    import java.time.Duration;
    import java.util.Set;
    import java.util.HashSet;

    public class Main {
        public static void main(String []args) {
            JedisPoolConfig poolConfig = new JedisPoolConfig();
            // 设置连接池的大小，-1 表示不限制大小。如果当前连接数超过这个值，新的连接会失败
            poolConfig.setMaxTotal(200);
            // 设置最大空闲连接数，超过这个范围的空闲连接会被立即释放
            poolConfig.setMaxIdle(10);
            // 设置最小空闲连接数，低于这个范围的空闲连接会被创建
            poolConfig.setMinIdle(3);
            // 当连接池中无可用连接且达到最大连接数时，业务最大等待时间
            poolConfig.setMaxWait(Duration.ofSeconds(1));
            // 在每次从连接池中拿连接时，PING 一下验证连接是否可用
            poolConfig.setTestOnBorrow(true);
            // 对空闲连接进行测试，发现无效的连接并释放，该配置只有在 timeBetweenEvictionRunsMillis 大于 1ms 时才会生效
            poolConfig.setTestWhileIdle(true);
            // 设置连接的最小空闲时间，超过这个时间的连接会被释放；-1 表示不释放，该配置只有在 timeBetweenEvictionRunsMillis 大于 0 时才会生效。默认值 30m
            poolConfig.setMinEvictableIdleDuration(Duration.ofMinutes(5));
            // 每次检测空闲连接时执行验证的连接数，-n 表示 1/n 个连接
            poolConfig.setNumTestsPerEvictionRun(-1);
            // 驱逐时间的间隔,-1 表示禁用
            poolConfig.setTimeBetweenEvictionRuns(Duration.ofMinutes(1));

            DefaultJedisClientConfig clientConfig = DefaultJedisClientConfig.builder()
                    // 客户端名称，用于 debug 时，查看连接来源
                    .clientName("demo-jedis")
                    // TCP连接超时时间
                    .connectionTimeoutMillis(2000)
                    // 命令超时时间
                    .timeoutMillis(10000)
                    .password("<password>")
                    .build();

            DefaultJedisClientConfig sentinelConfig = DefaultJedisClientConfig.builder()
                    .connectionTimeoutMillis(2000)
                    .timeoutMillis(10000)
                    .build();

            Set<HostAndPort> nodes =  new HashSet<>();
            nodes.add(new HostAndPort("<ip1>", "<port1>"));
            nodes.add(new HostAndPort("<ip2>", "<port2>"));
            JedisSentinelPool pool = new JedisSentinelPool("mymaster", nodes, poolConfig, clientConfig, sentinelConfig);

            try {
                try (Jedis jedis = pool.getResource()) {
                    String val = jedis.get("test");
                    System.out.printf("%s", val);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            pool.close();
        }
    }
    ```

    更多更详细配置请参考[社区文档](https://www.javadoc.io/doc/redis.clients/jedis/5.1.2/redis/clients/jedis/Jedis.html)

</Tab>

<Tab label="Lettuce">

    ```java
    package io.alauda.demo.redis;

    // 建议定期升级到客户端的最新版本，以获得最新的 bug 修复。
    import io.lettuce.core.ClientOptions;
    import io.lettuce.core.RedisURI;
    import io.lettuce.core.SocketOptions;
    import io.lettuce.core.TimeoutOptions;
    import io.lettuce.core.cluster.ClusterClientOptions;
    import io.lettuce.core.cluster.ClusterTopologyRefreshOptions;
    import io.lettuce.core.cluster.RedisClusterClient;
    import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
    import io.lettuce.core.support.ConnectionPoolSupport;
    import org.apache.commons.pool2.impl.GenericObjectPool;
    import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

    import java.time.Duration;
    import java.util.List;
    import java.util.ArrayList;

    public class Main {
        public static void main(String[] args) {
            RedisURI node1 = RedisURI.create("<ip1>", "<port1>");
            node1.setPassword("<password>");
            node1.setClientName("demo-lettuce");

            RedisURI node2 = RedisURI.create("<ip2>", "<port2>");
            node2.setPassword("<password>");
            node2.setClientName("demo-lettuce");

            List<RedisURI> nodes = new ArrayList<>();
            nodes.add(node1);
            nodes.add(node2);

            ClusterTopologyRefreshOptions refreshOptions = ClusterTopologyRefreshOptions.builder()
                    // 默认的刷新拓扑的时间间隔为 60 秒
                    .enablePeriodicRefresh()
                    // 在遇到如下错误时，触发拓扑刷新：ASK_REDIRECT,MOVED_REDIRECT,PERSISTENT_RECONNECTS,UNCOVERED_SLOT, UNKNOWN_NODE
                    .enableAllAdaptiveRefreshTriggers()
                    .build();

            TimeoutOptions timeoutOptions = TimeoutOptions.builder()
                    // 设置所有命令超时时间
                    .fixedTimeout(Duration.ofSeconds(10))
                    .build();

            SocketOptions socketOptions = SocketOptions.builder()
                    // 设置连接超时时间
                    .connectTimeout(Duration.ofSeconds(10))
                    .tcpNoDelay(true)
                    // 开启 TCP keepalive，用于快速发现无效连接
                    // 该值在非 pub/sub 类型的请求上不是必须的；可通过 idle 连接的及时释放来实现连接的探活
                    .keepAlive(true)
                    .build();

            ClusterClientOptions clusterClientOptions = ClusterClientOptions.builder()
                    .topologyRefreshOptions(refreshOptions)
                    // 设置命令超时时间
                    .timeoutOptions(timeoutOptions)
                    // 自动重连 (默认值)
                    .autoReconnect(true)
                    // 配置在连接断开时，客户端的行为。
                    // DEFAULT - autoReconnect = true 时，当有命令过来时，不会拒绝请求；否则拒绝命令发送
                    .disconnectedBehavior(ClientOptions.DisconnectedBehavior.DEFAULT)
                    // 配置 Socket 参数，lettuce 默认不开启 keepalive, 对业务上需要长连接的，需要开启此项
                    .socketOptions(socketOptions)
                    .build();

            RedisClusterClient redisClient = RedisClusterClient.create(nodes);
            redisClient.setOptions(clusterClientOptions);

            GenericObjectPoolConfig<StatefulRedisClusterConnection<String, String>> poolConfig = new GenericObjectPoolConfig<>();
            // 连接池大小，不可太大，不然会造成服务器连接资源的浪费，甚至造成连接数耗尽，导致实例自身的探活失败。
            // 建议 预估自己的业务并发，除以分片数，最终值是 1.2-1.5 倍即可
            poolConfig.setMaxTotal(200);
            // 最小空闲连接数，预留部分空闲连接，加速业务响应
            poolConfig.setMinIdle(3);
            // 最大空闲连接数，超过这个范围的空闲连接会被立即释放
            poolConfig.setMaxIdle(10);
            // 连接最小空闲时间
            poolConfig.setMinEvictableIdleDuration(Duration.ofMinutes(5));
            // 每次检测空闲连接时执行验证的连接数，-n 表示 1/n 个连接
            poolConfig.setNumTestsPerEvictionRun(3);
            // 驱逐时间的间隔,-1 表示禁用
            poolConfig.setTimeBetweenEvictionRuns(Duration.ofMinutes(1));
            // 当连接池中无可用连接且达到最大连接数时，业务最大等待时间
            poolConfig.setMaxWait(Duration.ofSeconds(1));
            // 在每次从连接池中拿连接时，PING 一下验证连接是否可用
            poolConfig.setTestOnBorrow(true);
            // 对空闲连接进行测试，发现无效的连接并释放，该配置只有在 timeBetweenEvictionRunsMillis 大于 1ms 时才会生效
            poolConfig.setTestWhileIdle(true);

            GenericObjectPool<StatefulRedisClusterConnection<String, String>> pool = ConnectionPoolSupport
                    .createGenericObjectPool(redisClient::connect, poolConfig);

            try {
                try (StatefulRedisClusterConnection<String, String> connection = pool.borrowObject()) {
                    String val = connection.sync().get("test");
                    System.out.printf("%s", val);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            pool.close();
        }
    }
    ```

    更多更详细配置请参考[社区文档](https://lettuce.io/core/release/reference/#redis-cluster)

</Tab>

<Tab label="Redisson">

    ```java
    package io.alauda.demo.redis;

    // 建议定期升级到客户端的最新版本，以获得最新的 bug 修复。
    import org.redisson.Redisson;
    import org.redisson.api.RedissonClient;
    import org.redisson.config.Config;

    import java.util.List;
    import java.util.ArrayList;

    public class Main {
        public static void main(String[] args) {
            List<String> nodes = new ArrayList<>();
            nodes.add("redis://<ip1>:<port1>");
            nodes.add("redis://<ip2>:<port2>");

            Config config = new Config();
            config
                    .setNettyThreads(64)
                    .useClusterServers()
                    .addNodeAddress(nodes.toArray(new String[0]))
                    .setPassword("<password>")
                    // 在服务启动时，检查集群 Slots 状态
                    .setCheckSlotsCoverage(true)
                    // 每次扫描集群拓扑的时间间隔
                    .setScanInterval(5000)
                    // 连接超时时间
                    .setConnectTimeout(10000)
                    // 命令超时时间
                    .setTimeout(10000)
                    // 30s 测试一次连接，用于检测连接可用性
                    // 如果开启了 KeepAlive，该值的时间可以相应变长
                    .setPingConnectionInterval(30000)
                    // 空闲连接超时时间 超过 60s 就放掉，默认 10s太短了
                    .setIdleConnectionTimeout(60000)
                    // 连接池大小，不可太大，不然会造成服务器连接资源的浪费，甚至造成连接数耗尽，导致实例自身的探活失败。
                    // 建议 预估自己的业务并发，除以分片数，最终值是 1.2-1.5 倍即可
                    .setMasterConnectionPoolSize(200)
                    // 最小空闲连接数，预留部分空闲连接，加速业务响应
                    .setMasterConnectionMinimumIdleSize(10)
                    // 失败命令重试次数
                    .setRetryAttempts(3)
                    // 失败命令重试时间间隔
                    .setRetryInterval(1500)
                    // TCP keepalive，启用TCP KeepAlive机制，连接会测试活性，快速发现意外断开的连接
                    .setKeepAlive(true)
                    // TCP no delay
                    .setTcpNoDelay(true)
                    // 客户端名称，用于 debug 时，查看连接来源
                    .setClientName("demo-redisson");
            RedissonClient redissonClient = Redisson.create(config);

            System.out.printf("%s", redissonClient.getBucket("test").get().toString());

            redissonClient.shutdown();
        }
    }
    ```

    更多更详细配置请参考[社区文档](https://redisson.org/docs/configuration/#cluster-mode)
</Tab>
</Tabs>
